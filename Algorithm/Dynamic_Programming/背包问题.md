# 背包问题

## 目录
- [1. 背包问题](#1-背包问题)  
  - [1.1. 01背包问题](#11-01背包问题)
  - [1.2. 完全背包问题](#12-完全背包问题)
- [2. 记忆化搜索](#2-记忆化搜索) 

## 1. 背包问题

### 1.1. 01背包问题
01背包问题是指：给定物品的价值和体积 (对应了 [ 给定价值和成本 ] ) ，在规定的容量下 (对应了 [ 限定决策规则 ] ) 如何使得所选物品的总价值达到最大;  

#### 题目描述:
有 N 件物品和一个容量是 V 的背包。每件物品有且只有一件。  
第 i 件物品的体积是 v[i] ，价值是 w[i] 。  
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。  

事例1:
```
输入：N = 3, V = 4, v = [4,2,3], w = [4,2,3];
输出：4
解释：只选择第一件物品，可使价值达到最大
```

事例2:
```
输入：N = 3, V = 5, v = [4,2,3], w = [4,2,3];
输出：5
解释：不选第一件物品，选择第二和第三件物品，可使价值达到最大
```

#### dp[N][C+1] 解法
如果要设计一个DFS函数对所有方案进行枚举的话，大概函数签名为：
```
int dfs (vector<int> & v, vector<int> & w, int i, int c)
```
其中 v 和 w 对应了输入的 [ 物品体积 ] 和 [ 物品价值 ] , 属于不变参数，无需考虑  
而 i 和 c 分别代表 [ 当前枚举到哪件物品 ] 和 [ 背包的剩余容量 ] 。  
返回值则是问题的答案：最大价值  

那么根据变化参数和返回值，可以抽象出相关的 dp 数组：  
一个二维数组，其中一维表示 [ 当前枚举到哪一件物品 ] , 另外一维表示 [ 现在的剩余容量]， 数组装的是最大价值。  
根据dp数组可以得出状态定义：  
考虑前 i 件物品，使用容量不超过 C 的条件下的背包最大价值;  
当有了状态定义之后，我们再根据 [ 最后一步 ] 来推导出 [ 状态转移方程 ]。

不失一般性的，只需要考虑第 i 件物品如何选择即可，对于第 i 件物品，可以有 [选] 和 [不选] 两种决策  

结合 [ 状态定义 ] , [不选] 的 [ 最大价值] 很好确定：    
[不选] 其实就是 dp[i-1][c] ,等效于只考虑前 i-1 件物品，当前容量为 c 的情况下得最大价值；  
同理，如果选择了第i件物品，代表消耗了 v[i] 的背包容量,获取了 w[i] 的价值，那么留给前 i-1 件物品的背包容量只剩 c-v[i]。最大价值为dp[i-1][c-v[i]] + w[i];  
当然，选择第 i 件物品还有个必要的前提，就是 [物品的体积] <= [当前背包的剩余容量];

在「选」和「不选」之间取最大值，就是我们 [考虑前 i 件物品，使用容量不超过 C] 的条件下的「背包最大价值」。  
即可得「状态转移方程」为：
```c++
dp[i][c] = max (dp[i-1][c] , dp[i-1][c-v[i]] + w[i]);
```

代码：  
```c++
class Solution {
public:
    int maxValue (int N, int C, vector<int> & v, vector<int> & w) {
    
        vector<vector<int>> dp(N,vector<int>(C+1));
        
        //先处理考虑[第一件物品]的情况
        for (int i=0; i<=C; i++) {
            dp[0][i] = i >= v[0] ? w[0] : 0;
        }
        
        //在处理考虑[其他物品]的情况
        for (int i=1; i<N; i++) {
            for (int j=0; j<C+1; j++) {
                //不选第i件物品
                int n = dp[i-1][j];
                // 选择第i件物品，前提是[剩余容量] 大于[背包的剩余容积]
                int y = j >= v[i] ? dp[i-1][j-v[i]] + w[i] : 0;
                dp[i][j] = max(n,y);
            }
        }
        
        return dp[N-1][C];
    }
};
```
时间复杂度：共有 N\*C 个状态需要转移，复杂度为O(N\*C)  
空间复杂度：O(N*C)  

#### d[2][C+1]解法

根据[转移方程],计算第 i 行格子只需要 i - 1 行中的某些值;  
也就是计算 [某一行] 的时候只需要依赖 [前一行];  
因此可以使用一个只有两行的数组来存储中间结果，根据当前计算的行号是奇数还是偶数来交替使用第 0 行和第 1 行；  
这样的空间优化方法称为[滚动数组];  
只需要将代表行的的维度修改成2，并将所有使用行维度的地方从 i 改成 i%2 或者 i&1 即可（更建议使用 i&1 ， & 运算在不同 CPU 架构的机器上要比 % 运算稳定）

代码如下:
```c++
class Solution {
public:
    int maxValue (int N, int C, vector<int> & v, vector<int> & w) {
        vector<vector<int>> dp(2,vector<int>(C+1));
        
         //先处理考虑[第一件物品]的情况
        for (int i=0; i<=C; i++) {
            dp[0][i] = i >= v[0] ? w[0] : 0;
        }
        
         //在处理考虑[其他物品]的情况
        for (int i=1; i<N; i++) {
            for (int j=0; j<C+1; j++) {
                //不选第i件物品
                int n = dp[(i-1)&1][j];
                // 选择第i件物品，前提是[剩余容量] 大于[背包的剩余容积]
                int y = j >= v[i] ? dp[(i-1)&1][j-v[i]] + w[i] : 0;
                dp[i&1][j] = max(n,y);
            }
        }
        
        return dp[(N-1)&1][C]
    }
};
```
时间复杂度：共有 N\*C 个状态需要转移，复杂度为O(N\*C)   
空间复杂度：O(C)  

#### dp[C+1]解法
事实上，还能继续进行空间优化，只保留代表「剩余容量」的维度。  
再次观察「转移方程」：  
```c++
dp[i][c] = max (dp[i-1][c] , dp[i-1][c-v[i]] + w[i]);
```
不难发现当求解第 i 行格子的值时，不仅是只依赖第 i-1 行，还明确只依赖第 i-1 行的第 c 个格子和第 c-v[i] 个格子（也就是对应着第 i 个物品不选和选的两种情况）。  
换句话说，只依赖于「上一个格子的位置」以及「上一个格子的左边位置」。  
![image](https://github.com/Feng3333/Algorithm-and-data-structure/blob/ab77ba4608864715c648ec1923b30d7abc98ff1a/images-folder/dp1.png)  
因此，只要我们将求解的第 i 个格子的顺序 [从0到c] 改为 [从c到0] ，就可以将原本2行的的二维数组压缩到1行 (转换为一维数组)    
*这样做的空间复杂度和「滚动数组」优化的空间复杂度是一样的。但仍然具有意义，而且这样的「一维空间」优化，是求解其他背包问题的基础，需要重点掌握*  

具体代码：
```c++
class Solution {
public:
    int masValue(int N, int C, vector<int> & v, vector<int> & w) {
        vector<int> dp(C+1);
        for (int i=0; i<N; i++) {
            for (int j=C; j>=v[i]; j--) {
                //不选该物品
                int n = dp[j];
                //选择该物品
                int y = dp[j-v[i]]+w[i];
                dp[j] = max(n,y);
            }
        }
        
        return dp[C];
    }
}
```
时间复杂度：共有 N\*C 个状态需要转移，复杂度为O(N\*C)   
空间复杂度：O(C) 


###  1.2. 完全背包问题
#### 题目描述
有 N 种物品和一个容量为 C 的背包，每种物品的个数都是无限的;  
第 i 件物品的体积是 v[i] ,价值是 w[i];  
求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。  
tips：其实就是在 01-背包问题的基础上，增加了每件物品可以选择多次的特点（在背包容量允许的情况下）  

示例 1
```
输入： N=2, C=5, v = [1,2] , w = [1,2];
输出：5
解释：选一件物品 1 ，再选两件物品2 ，可以使总价值达到最大
```

#### 常规解法
这里可以直接将 01背包的 [状态定义] 拿过来用:    
dp[i][j] 代表考虑前 i 件物品，放入一个容量为 j 的背包可以获得的最大价值。  
由于每件物品可以被选择多次，因此对于某个 dp[i][j] 而言，其值应该为以下所有可能方案中的最大值：
 .选择 0 件物品 i 的最大价值，即 dp[i-1][j];  
 .选择 1 件物品 i 的最大价值，即 dp[i-1][j-v[i]] + w[i];    
 .选择 2 件物品 i 的最大价值，即 dp[i-1][j-2*v[i]] + 2\*w[i];    
 . . .    
 
 .选择 k 件物品 i 的最大价值，即 dp[i-1][j-k*v[i]] + k\*w[i];     
 
由此可以得出 [状态转移方程] 为:  
```
dp[i][j] = max(dp[i-1][j],dp[i-1][j-k*v[i]] + k*w[i]);
```

代码实现:
```c++
class Solution {
public:
    int maxValue (int N, int C, vector<int> & v, vector<int> & w) {
        vector<vector<int>> dp(N,vector<int>(C+1));
        
        //先预处理第一件物品
        for (int j=0; j<=C; ++j) {
            //当只有一件物品的时候，在容量允许的情况下，能选多少件就选多少件
            int maxK = j/v[0];
            dp[0][j] = maxK*w[0];
        }
        
        //处理其余物品
        for (int i=0; i<N; i++) {
            for (int j=0; j<=C; j++) {
                //不选则第i件物品
                int n = dp[i-1][j];
                
                //考虑第i件物品的情况
                int y=0;
                for (int k=1; ;k++) {
                    if (j < v[i]*k) {
                        break;
                    }
                    y = max(y,dp[i-1][j-k*v[i]] + k* w[i]);
                }
                dp[i][j] = max(n,y);
            }
        }
        
        return dp[N-1][C];
    }
}
```
时间复杂度：共有 N\*C个状态需要转移，但每次转移都需要枚举当前物品的件数，最多枚举 C 次(重量为最小值 1) ，因此整体复杂度为 O(N\*C\*C);  
空间复杂度：O(N\*C)

#### [滚动数组]解法
 通过观察[状态转移方程]可以发现，在更新某个dp[i][x]的时候只依赖于dp[i-1][x];
 因此可以像 01背包 那样使用 [滚动数组] 的方式将空间优化到 O(C);  
 
 代码实现：
 ```c++
 class Solution {
 public:
     int maxValue(int N, int C, vector<int> & v, vector<int> & w) {
         vector<vector<int>> dp(2,vector<int>(C+1));
         
          //先预处理第一件物品
        for (int j=0; j<=C; ++j) {
            //当只有一件物品的时候，在容量允许的情况下，能选多少件就选多少件
            int maxK = j/v[0];
            dp[0][j] = maxK*w[0];
        }
        
     }
 }
 ```
 时间复杂度：共有 N\*C 状态需要转移，但每次转移都需要枚举当前物品的件数，最多枚举C（重量为最小值1）次，因此整体复杂度为 O(N\*C\*C);  
 空间复杂度：O(N\*C)  
 
#### [一维空间优化]解法

在01背包问题中，最重要的就是[一维空间优化]解法。  
之所以 01背包 中可以使用[一维空间优化]解法，是因为当开始处理第 i 件物品的时候，数组中存储的是已经处理完的第 i-1 件物品的状态值；  
然后配合着容量维度[从大到小]的遍历顺序，可以确保我们在更新某个状态时，所需要用到的状态值不会被覆盖。   
因此 01背包问题 的转移状态方程为：
```
dp[j] = max(dp[j], dp[j-v[i]] + w[i]);
```
同时容量维度的遍历顺序为从大到小。  

而 [完全背包] 区别于 [01背包] 在于：每件物品可以被选择多次。  
接下来，让我们跟随三页姐的脚步从  [数学] 的角度去证明为什么修改 01背包 的遍历顺序可以正确求解完全背包问题 。

首先展开完全背包中 dp[i][j] 的所有可能方案：   
```c++
dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i],  dp[i-1][j- 2*v[i]] + 2*w[i], .... ,  dp[i-1][j-k*v[i]] + k*w[i] );
```
dp[i][j]所代表的含义：在容量允许的情况下，对于第 i 件物品，我们可以不选，可以选择 1 次，可以选择 2 次，..... 可以选择 k 次...  
然后通过代入，看看 dp[i][j-v[i]] 是什么内容:
```
dp[i][j-v[i]] = max(dp[i-1][j-v[i]], dp[i-1][j-2*v[i]]+w[i], dp[i-1][j-3*v[i]]+2*w[i], ....dp[i-1][j-k*v[i]]+(k-1)*w[i]); //k*v[i]>=0 && k*v[i] <= j  
```

光看公式比较难看出两者之间的联系，让我们来看下 三叶姐 的讲解：  
![image](https://github.com/Feng3333/Algorithm-and-Data-Structure/blob/6c90cf5a4f5292314f2fb299d901ea45716cdb8d/images-folder/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%851.png)  

总结一下：  
。 01背包问题的状态转移方程是：
```
dp[j] = max(dp[j], dp[j-v[i]] + w[i]);
```
由于计算dp[i][j]的时候，依赖于 dp[i-1][j-v[i]];  
因此在改为 [一维空间优化] 的时候，需要确保 dp[j-v[i]] 存储的是上一行的值，即确保 dp[j-v[i]] 还没有被更新,所以遍历的方向是从大到小。  

。 完全背包的状态转移方程是：  
```
dp[i][j] = max(dp[i-1][j], dp[i][j-v[i]+w[i]]);
```
由于计算dp[i][j]的时候，依赖于 dp[i][j-v[i]]; 
因此在改为 [一维空间优化] 的时候，需要确保 dp[j-v[i]] 存储的是当前行的值，即确保 dp[j-v[i]] 已经被更新,所以遍历的方向是从小到大。  

具体代码：
```c++
class Solution {
public:
    int maxValue(int N, int C, vector<int> &v, vector<int> & w) {
    
        vector<int> dp(C+1);
        
        for (int i=0; i<N; i++) {
            for (int j=0; j<=C; j++) {
                //不考虑第 i 件物品的情况
                int n = dp[j];
                //考虑第 i 件物品的情况
                int y = j-v[i] >= 0 ? dp[j-v[i]] + w[i] : 0 ;
                dp[j] = max(n,y);
            }
        }
        
        return dp[C];
    }
}
```
时间复杂度：共有 N\*C 个状态需要转移，复杂度为：O(N\*C)；  

空间复杂度：O(C)
